## 프로세스란

- 메모리에 올려져서 실행중인 프로그램

- 프로그램 != 프로세스

- 프로그램이 실행돼서 돌아가고있는 상태가 프로세스


## 프로세스 스케쥴링

#### 배치 처리 시스템

- FIFO방식이며, 한번에 등록된 여러프로그램들을 컴퓨터 프로그램의 실행 요청 순서에 따라 순차적으로 실행하는 방식

- 단점:
    - 하나의 프로그램이 끝날때 까지 다른 프로그램은 계속 대기해야됨
    - 따라서 동시에 여러 프로그램 실행X
    - 여러 사용자가 동시에 하나의 컴퓨터를 사용못한다. 응답시간에 영향을 받는다

- 그래서 시분할 시스템/멀티 프로그래밍이 나왔다 

#### 시분할 시스템

- 여러 사용자(다중 사용자 지원)가 동시에 하나의 컴퓨터를 사용할 수 있다. 응답시간 최소화

#### 멀티 태스킹

- 단일CPU(코어) 에서 여러 프로그램들이 돌아가면서 조금씩 실행되는것. 마치 동시에 실행되는 것 처럼 보임

#### 멀티 프로세싱

- 여러CPU(다중코어) 에서 각각 하나의 프로그램을 병렬로 동시에 실행하는것

#### 멀티 프로그래밍

- CPU 활용도를 극대화 하는 스케쥴링 알고리즘

- 여러 개의 프로그램을 메모리에 올려놓고 동시에 실행. IO 작업이나 저장매체 갔다오는 작업을 하는 동안(wait) CPU가 노니까 그때 다른 프로세스 실행

## 스케쥴러

- 프로세스 실행을 관리하는 것

- 다양한 스케쥴링 알고리즘 들이 존재

#### FIFO 스케쥴러
    - 가장 간단한 스케쥴러(배치 처리 시스템)
    - 정해진 순서대로 프로세스가 실행된다
    - 수행시간(Run Time)이 긴 프로세스가 있을 경우, 나머지 프로세스들의 Waiting Time이 증가
    - 따라서, CPU 효율성이 낮아진다
```shell
	P1 : RunTime = 30ms,
	P2 : RunTime = 10ms,
	P3 : RunTime = 10ms 이라면

	P1 : WaitingTime = 0ms
	P2 : WaitingTime = 30ms
	P3 : WaitingTime = 40ms 이고

	평균 WaitingTime은 70/3 = 23.4ms
```

#### 최단 작업 우선(SJF) 스케쥴러
    - 가장 프로세스 수행시간(Run Time)이 짧은 프로세스부터 먼저 실행하는 알고리즘
    - 평균 Waiting Time이 줄어든다

```shell
	P1 : RunTime = 30ms,
	P2 : RunTime = 10ms,
	P3 : RunTime = 10ms 이라면

	P2 : WaitingTime = 0ms
	P3 : WaitingTime = 10ms
	P1 : WaitingTime = 20ms 이고

	평균 WaitingTime은 30/3 = 10ms
```
    - 수행시간이 긴 프로세스는 계속 뒤로 물러나는 기아현상(Starvation)이 발생 할 수 있다
    - 근데 현실적으로 각 프로세스의 수행시간이 얼마나 걸릴지는 해봐야 아는거지 미리 알 수 없기에 이상적인 알고리즘이긴하다
    - 선점형 : 하나의 프로세스가 수행중인 도중에 갑자기 다른 프로세스 요청(짧은 수행시간의)이 들어오면중간에 끊고 다음 프로세스가 수행되고 나중에 나머지가 수행되는것(SJF니까 수행시간 짧은거부터 해야되자나)
    - 비선점형 : 하나의 프로세스가 다 수행된후에 다음 프로세스 수행가능

#### Round Robin 스케쥴러
    - 기아현상을 해결하기 위한 알고리즘
    - FIFO구조
    - 프로세스마다 균등하게 시간을 배분해서 돌아가면서 수행되는것
    - 즉 시분할 시스템이다

#### 우선순위 기반 스케쥴러
    - 기아현상을 해결하면서 우선순위가 높은거에 높은 비율을 배분해주는것(Round Robin의 업그레이드)
    - 프로세스마다 우선순위를 미리 지정. 스케쥴러가 상황에 따라 우선순위를 동적으로 변경
    - 우선순위가 낮은 프로세스가 계속 수행이 지연되는 기아현상이 발생하지만 에이징기법을 사용해 오래 대기한 프로세스의 동적 우선순위를 높여서 기아현상을 줄인다

#### 프로세스 상태 기반 스케쥴러
    - 멀티 프로그래밍같은것
    - 큐(FIFO)구조
    - 3가지 상태가 존재(Ready State Queue, Running State Queue, Block State Queue(Wait 상태))
```shell
	1. 프로세스 순서대로 Ready State Queue에 배정되고 CPU에서 순서대로 실행
	2. 만약 프로세스가 메모리에 파일을 가져오는 waiting 시간 동안 이 프로세스는 Block State Queue에 배정됨
	3. waiting 이 끝나면 다시  Ready State Queue에 배정
	4. 만약 Ready State Queue에 배정된 프로세스가 없다면 CPU는 idle 상태가 됨
```
