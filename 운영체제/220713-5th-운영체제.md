# 가상 메모리

- 프로세스는 메모리 영역이 기본으로 4GB인데, 그럼 내 컴퓨터가 8기가짜리면 프로세스 두개 띄우면 끝? 아니다

- 기존에는 프로세스가 실행되는 코드의 전체 4GB가 통채로 메모리(램)에 로드해야 했고 메모리 용량보다 더 큰 프로그램은 실행시킬 수 없었다

- 하지만 가상 메모리를 사용하므로서 프로세스를 실행할 때 실행에 필요한 일부만 메모리(램)에 로드하고 나머지는 디스크에 두는것

- 메모리는 가상메모리(프로세스의) 와 물리메모리(램) 둘로 나뉜다 

- 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 바뀐다


## 페이징 시스템(가상 메모리를 어떻게 만들건데?)

- 요즘에는 페이징 시스템만 사용한다

- 프로세스의 메모리영역(4GB)를 특정 사이즈 단위로 조각내는것

- 그리고 각각에 페이지 번호를 메긴다. 그 단위로 메모리(램)에 적재되었다 해제되었다 하는 것 

- intel의 경우 4KB, 2MB, 1GB 지원

- 리눅스의 경우 4KB 페이징

## MMU(Memory Management Unit) (CPU코어에 들어있는 칩)

- CPU에 코드 실행시 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치 

- 즉, CPU는 가상 메모리를 다루고 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근

- 동작원리 :

    - 1. CPU가 MMU에게 가상 주소 요청

    - 2. MMU가 메모리(램)의 page table로 접근(page table : 가상주소와 실제 물리 주소 값의 관계를 나타내는 테이블)

    - 3. 해당 가상 주소에 해당하는 물리 주소를 MMU에 요청

    - 4. MMU에서 해당 물리 주소에 해당하는 실제 데이터 값을 가지러 메모리(램)에 재접근

    - 5. 실제 데이터 값을 CPU에 전달

- 하나의 주소 가져올때 메모리에 왔다갔다하면서 소요되는 시간이 너무 오래걸림. 심지어 두번이나. 그래서 TLB 등장

## TLB(CPU코어에 들어있는 칩. 캐쉬메모리)

- 동작원리는 MMU와 유사하지만 CPU가 동일한 가상주소를 다음번에 요청할때 이점을 가짐

- 동작원리 :

    - 1. CPU가 MMU에게 가상 주소 요청

    - 2. MMU가 메모리(램)의 page table로 접근(page table : 가상주소와 실제 물리 주소 값의 관계를 나타내는 테이블)

    - 3. 해당 가상 주소에 해당하는 물리 주소를 MMU에 요청

    - 4. 해당 물리 주소를 TLB에 저장

    - 5. MMU에서 해당 물리 주소에 해당하는 실제 데이터 값을 가지러 메모리(램)에 재접근

    - 6. 실제 데이터 값을 CPU에 전달

    - 7. CPU가 동일한 가상 주소를 재요청

    - 8. TLB에 재요청한 가상 주소에 해당하는 물리주소 값이 저장되어있으니 해당 물리주소에 해당하는 데이터값을 가지러 메모리로 이동

    - 9. 해당 데이터값 CPU에 전달

- 즉, CPU가 이전에 요청했었던 동일한 가상 주소를 재요청할 때 MMU는 메모리에 두번 왔다갔다해야되고, TLB는 한번만 함

## 요구 페이징

- 프로세스의 모든 데이터를 메모리에 적재하지않고, 실행 중 필요한 시점에서만 메모리에 적재함

- 프로세스의 모든 데이터를 메모리에 적재하면 프로세스를 실행하는데 걸리는 준비시간이 너무 기니까 당장 급한것들만 적재

## 페이지 폴트

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트

- 인터럽트 : CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하는 것

## 페이지 폴트 인터럽트

- 동작원리 :

    - 1. CPU가 MMU에게 가상 주소 요청

    - 2. TLB에 가상 주소에 해당하는 물리 주소가 있는지 확인

    - 3. 없다면 메모리(램)의 page table로 접근

    - 4. 가상 주소에 해당하는 물리주소가 메모리의 page table에 없으면 페이지 폴트 인터럽트 발생

    - 5. 페이지 폴트 인터럽트에 의해 가상 주소에 해당하는 물리 주소를 가지러 하드디스크(저장매체)에 접근

    - 6. 해당 물리 주소를 메모리 page table에 update. 데이터값도 같이 update

    - 7. CPU가 다시 가상 주소 요청

    - 8. TLB 동작원리대로 진행

- 페이지 퐅트가 일어나면 저장매체갔다와야하고 과정 자체가 너무 오래걸린다. 이를 해결하기 위해선 향후 실행될 데이터를 미리 물리 메모리에 올려야 하는데 이건 불가능..

## 페이지 교체 정책(참고만..)

- 운영체제가 특정 페이지를 물리 메모리에 올리려하는데 물리 메모리가 다 차있을 경우 해결방안 알고리즘

- 종류 :

    - FIFO : 가장 먼저 들어온 페이지를 먼저 내리자

    - OPT : 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자(이건 현실적으로 불가능..)

    - LRU : 가장 오래전에 사용된 페이지를 교체

    - LFU : 가장 적게 사용된 페이지를 내리자

    - NUR : LRU와 같이 가장 오래전에 사용된 페이즈를 교체하지만 그 페이지가 읽기만했냐 읽고쓰기도했냐 하는것들 따짐

