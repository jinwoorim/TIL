# 트리

- Node와 Branch를 이용해서 사이클을 이루지 않도록 구성한 데이터 구조
- 이진 트리가 주로 쓰인다.. 탐색 알고리즘 구현에서 많이 쓰인다

## 이진 트리

- 이진 트리 : 노드의 최대 Branch가 2인 트리
- 이진 탐색 트리 : 왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰값

## 트리 구현

```shell
package practice24;

 class NodeMgmt {
    Node head = null;
    
     class Node {
        Node left;
        Node right;
        int value;
         Node (int data) {
            this.value = data;
            this.left = null;
            this.right = null;
        }
    }
    
    void insertNode(int data) {
        // CASE1: Node 가 하나도 없을 때
        if (this.head == null) {
            this.head = new Node(data);
        } else {
            // CASE2: Node 가 하나 이상 들어가 있을 때
            Node findNode = this.head;
            while (true) {
                // CASE2-1: 현재 Node 의 왼쪽에 Node 가 들어가야할 때
                if (data < findNode.value) {
                    if (findNode.left != null) {
                        findNode = findNode.left;
                    } else {
                        findNode.left = new Node(data);
                        break;
                    }
                // CASE2-2: 현재 Node 의 오른쪽에 Node 가 들어가야할 때                    
                } else {
                    if (findNode.right != null) {
                        findNode = findNode.right;
                    } else {
                        findNode.right = new Node(data);
                        break;
                    }
                }
            }
        }
             
    }
    
    Node search(int data) {
        // CASE1: Node 가 하나도 없을 때
        if (this.head == null) {
            return null;
        // CASE2: Node 가 하나 이상 있을 때            
        } else {
            Node findNode = this.head;
            while (findNode != null) {
                if (findNode.value == data) {
                    return findNode;
                } else if (data < findNode.value) {
                    findNode = findNode.left;
                } else {
                    findNode = findNode.right;
                }
            }
            return null;
        }
    }   
}

public class TreeTest {

	public static void main(String[] args) {

		NodeMgmt myTree = new NodeMgmt();
		myTree.insertNode(5);
		myTree.insertNode(10);
		myTree.insertNode(8);
		myTree.insertNode(12);
		
		System.out.println(myTree.search(10).left.value);
		System.out.println(myTree.search(10).right.value);
	}

}
```
